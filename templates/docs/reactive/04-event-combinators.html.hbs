<p>Events can be transformed and combined using a rich set of combinators. All SpiderM variants
automatically manage subscriptions and node IDs.</p>

<table class="api-table">
  <thead>
    <tr><th>Combinator</th><th>Type</th><th>Description</th></tr>
  </thead>
  <tbody>
    <tr><td><code>Event.mapM f e</code></td><td><code>(a → b) → Evt a → SpiderM (Evt b)</code></td><td>Transform each value</td></tr>
    <tr><td><code>Event.filterM p e</code></td><td><code>(a → Bool) → Evt a → SpiderM (Evt a)</code></td><td>Keep values matching predicate</td></tr>
    <tr><td><code>Event.mapMaybeM f e</code></td><td><code>(a → Option b) → Evt a → SpiderM (Evt b)</code></td><td>Filter + transform</td></tr>
    <tr><td><code>Event.mergeM e1 e2</code></td><td><code>Evt a → Evt a → SpiderM (Evt a)</code></td><td>Combine two event streams</td></tr>
    <tr><td><code>Event.tagM b e</code></td><td><code>Beh a → Evt b → SpiderM (Evt a)</code></td><td>Sample behavior on event</td></tr>
    <tr><td><code>Event.attachM b e</code></td><td><code>Beh a → Evt c → SpiderM (Evt (a × c))</code></td><td>Pair behavior with event</td></tr>
    <tr><td><code>Event.gateM b e</code></td><td><code>Beh Bool → Evt a → SpiderM (Evt a)</code></td><td>Pass events only when behavior is true</td></tr>
    <tr><td><code>Event.accumulateM f init e</code></td><td><code>(a → b → b) → b → Evt a → SpiderM (Evt b)</code></td><td>Running fold over events</td></tr>
    <tr><td><code>Event.distinctM e</code></td><td><code>[BEq a] → Evt a → SpiderM (Evt a)</code></td><td>Skip consecutive duplicates</td></tr>
    <tr><td><code>Event.zipEM e1 e2</code></td><td><code>Evt a → Evt b → SpiderM (Evt (a × b))</code></td><td>Pair simultaneous events</td></tr>
    <tr><td><code>Event.differenceM e1 e2</code></td><td><code>Evt a → Evt b → SpiderM (Evt a)</code></td><td>Fire e1 only when e2 doesn't</td></tr>
  </tbody>
</table>

<h4>Example: Filtered Counter</h4>
<pre><code class="language-lean">-- Count only even numbers
let (numbers, fireNum) ← newTriggerEvent
let evens ← Event.filterM (· % 2 == 0) numbers
let evenCount ← foldDyn (fun _ n => n + 1) 0 evens</code></pre>
