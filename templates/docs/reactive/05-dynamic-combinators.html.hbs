<p>Dynamics represent state that changes over time. They combine the sampling capability of
Behaviors with change notifications.</p>

<table class="api-table">
  <thead>
    <tr><th>Combinator</th><th>Description</th></tr>
  </thead>
  <tbody>
    <tr><td><code>holdDyn init e</code></td><td>Create Dynamic holding latest event value</td></tr>
    <tr><td><code>foldDyn f init e</code></td><td>Fold over events to build state</td></tr>
    <tr><td><code>Dynamic.mapM f d</code></td><td>Transform Dynamic values (no dedup)</td></tr>
    <tr><td><code>Dynamic.mapUniqM f d</code></td><td>Transform with BEq deduplication</td></tr>
    <tr><td><code>Dynamic.zipWithM f d1 d2</code></td><td>Combine two Dynamics</td></tr>
    <tr><td><code>Dynamic.switchM dd</code></td><td>Flatten <code>Dyn (Dyn a)</code> → <code>Dyn a</code></td></tr>
  </tbody>
</table>

<h4>Example: Derived State</h4>
<pre><code class="language-lean">-- Two counters and their sum
let (incA, fireA) ← newTriggerEvent
let (incB, fireB) ← newTriggerEvent

let countA ← foldDyn (fun _ n => n + 1) 0 incA
let countB ← foldDyn (fun _ n => n + 1) 0 incB
let total ← Dynamic.zipWithM (· + ·) countA countB

-- total automatically updates when either counter changes</code></pre>
